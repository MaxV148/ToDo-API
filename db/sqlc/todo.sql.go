// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: todo.sql

package db

import (
	"context"
	"time"
)

const createToDo = `-- name: CreateToDo :one
INSERT INTO todo (title, content, created_by, category)
VALUES ($1, $2, $3, $4)
RETURNING id, title, content, done, created_by, category, created_at
`

type CreateToDoParams struct {
	Title     string
	Content   string
	CreatedBy int64
	Category  int64
}

func (q *Queries) CreateToDo(ctx context.Context, arg CreateToDoParams) (Todo, error) {
	row := q.db.QueryRowContext(ctx, createToDo,
		arg.Title,
		arg.Content,
		arg.CreatedBy,
		arg.Category,
	)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Done,
		&i.CreatedBy,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const deleteToDo = `-- name: DeleteToDo :one
DELETE
FROM todo
WHERE id = $1
  AND created_by = $2
RETURNING id, title, content, done, created_by, category, created_at
`

type DeleteToDoParams struct {
	ID        int64
	CreatedBy int64
}

func (q *Queries) DeleteToDo(ctx context.Context, arg DeleteToDoParams) (Todo, error) {
	row := q.db.QueryRowContext(ctx, deleteToDo, arg.ID, arg.CreatedBy)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Done,
		&i.CreatedBy,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const listToDoForUser = `-- name: ListToDoForUser :many
SELECT todo.id,
       title,
       content,
       done,
       "name" as CategoryName,
       todo.created_at,
       created_by,
       username
FROM todo
         LEFT JOIN todo_permissions ON todo.id = todo_permissions.todo_id AND todo_permissions.user_id = $1
         JOIN category ON todo.category = category.id
         JOIN "user" ON todo.created_by = "user".id
WHERE created_by = $1
   OR todo_permissions.user_id = $1
ORDER BY
    CASE WHEN $2 = 'TITLE_ASC' THEN title END,
    CASE WHEN $2 = 'TITLE_DESC' THEN title END DESC,
    CASE WHEN $2 = 'DONE_ASC' THEN done END,
    CASE WHEN $2 = 'DONE_DESC' THEN done END DESC,
    CASE WHEN $2 = 'CATEGORY_ASC' THEN name END,
    CASE WHEN $2 = 'CATEGORY_DESC' THEN name END DESC,
    CASE WHEN $2 = 'CREATED_AT_ASC' THEN todo.created_at END,
    CASE WHEN $2 = 'CREATED_AT_DESC' THEN todo.created_by END DESC,
    CASE WHEN $2 = 'AUTHOR_ASC' THEN username END,
    CASE WHEN $2 = 'AUTHOR_DESC' THEN username END DESC
`

type ListToDoForUserParams struct {
	UserID       int64
	SortingOrder interface{}
}

type ListToDoForUserRow struct {
	ID           int64
	Title        string
	Content      string
	Done         bool
	Categoryname string
	CreatedAt    time.Time
	CreatedBy    int64
	Username     string
}

func (q *Queries) ListToDoForUser(ctx context.Context, arg ListToDoForUserParams) ([]ListToDoForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listToDoForUser, arg.UserID, arg.SortingOrder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListToDoForUserRow{}
	for rows.Next() {
		var i ListToDoForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Done,
			&i.Categoryname,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleToDoDone = `-- name: ToggleToDoDone :one
UPDATE todo
set done = NOT todo.done
where id = $1
RETURNING id, title, content, done, created_by, category, created_at
`

func (q *Queries) ToggleToDoDone(ctx context.Context, id int64) (Todo, error) {
	row := q.db.QueryRowContext(ctx, toggleToDoDone, id)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Done,
		&i.CreatedBy,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const updateToDo = `-- name: UpdateToDo :one
UPDATE todo
SET title   = coalesce($2, title),
    content = coalesce($3, content)
WHERE id = $1
RETURNING id, title, content, done, created_by, category, created_at
`

type UpdateToDoParams struct {
	ID      int64
	Title   string
	Content string
}

func (q *Queries) UpdateToDo(ctx context.Context, arg UpdateToDoParams) (Todo, error) {
	row := q.db.QueryRowContext(ctx, updateToDo, arg.ID, arg.Title, arg.Content)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Done,
		&i.CreatedBy,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}
